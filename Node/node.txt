***Node
0.node.js
=>애플리케이션 개발을 위한 자바스크립트 프레임워크 또는 라이브러리
=>노드 만으로 애플리케이션 개발을 하기도 하지만 다른 자바스크립트 라이브러리의 기반 프레임워크가 되기도 함

1.개발 환경 설정
1)노드 설치: https://nodejs.org/ 에서 LTS(안정화 된 버전) 버전을 다운로드 받아서 설치
=>터미널에서 설치 확인
node -v
npm -v

=>npm: 노드의 패키지 관리자

2)IDE: Visual Studio Code 

2.프로젝트 생성 및 실행
1)프로젝트 생성
=>빈 디렉토리에서 npm init 이라는 명령어로 옵션을 설정하면 됩니다.
프로젝트를 생성하는데 성공하면 프로젝트 설정 파일인 package.json 파일이 생성되고 옵션이 설정되어 있습니다.
옵션은 package.json 파일에서 수정이 가능합니다.

=>옵션 중에서 package 이름과 디렉토리 이름이 같으면 배포가 안됩니다. 

2)프로젝트 실행
=>프로젝트 실행: npm start(pakage.json 파일에 설정한 entry point 파일이 실행)
=>특정 파일 실행: node 파일경로

=>학습을 할 때는 파일을 실행하지만 프로젝트를 할 때는 프로젝트를 실행

3)console.log
=>콘솔에 메시지를 출력하는 함수인데 함수의 결과는 터미널에 출력됩니다.

4.Node 내장 객체
=>node 가 제공하는 객체
1)global
=>노드의 전역 객체
=>이 객체는 노드 프로그램 전체에서 1개만 생성
=>이 객체는 하나만 만들어서 노드 프로그램 전체가 공유
=>사용하는 것을 권장하지는 않지만 모든 곳에서 사용해야 할 데이터가 있는 경우 사용
예를 들면 현재 접속자 수 나 대기자 수 또는 로고 등은 모든 사용자에게 동일하게 보여집니다.
이런 데이터를 global을 이용해서 사용합니다.

2)console
=>현재 보여지는 터미널 화면
console.log(메시지): 메시지 로깅

console.error(메시지): 에러 형태로 로깅

console.trace(메시지): 호출 스택 로깅 - 함수 나 메서드를 호출하는 순서를 역순으로 출력
호출하는 메서드의 순서를 확인하고자 할 때 사용

console.table(배열): 테이블 형태로 출력

console.time(메시지) & console.timeEnd(메시지): 동일한 메시지를 사용하면 2개 호출 사이의 시간을 출력 

console.dir(객체, 옵션): 객체를 로깅할 때 옵션을 설정하는 것이 가능

=>로직이 복잡해지거나 여러 모듈을 거쳐가면서 수행되는 코드가 있다면 중간 중간 로그를 출력해서 확인을 하는 것이 좋습니다.
로그를 출력하는 작업을 한 것은 배포를 할 때 모두 제거해야 합니다.
필요하다면 로그는 파일이나 데이터베이스에 기록하는 것이 좋습니다.
로그를 콘솔에 출력하는 것은 개발 과정에서만 합니다.

4)module.exports
=>모듈의 내용을 다른 곳에서 사용할 수 있도록 하고자 할 때 사용하는 속성
module.exports = 내보낼 내용;

=>exports.내보내고자하는이름 = 내용; 으로 해도 동일한 기능

5)this
=>함수 나 클래스 외부에서는 module.exports
=>함수 안에서는 global
=>클래스의 메서드 안에서는 인스턴스

6)require 함수
=>외부 모듈의 내용을 가져올 때 사용하는 함수
=>import 도 외부 모듈을 가져오는데 사용할 수 있지만 require 는 caching을 합니다.
한 번 사용한 모듈을 메모리에 적재해두었다가 다음에 require를 하게되면 캐싱된 모듈을 가져옵니다.
=>.js 는 생략 가능

7)process 객체
=>노드 프로세스에 대한 정보를 가지는 객체

=>노드 버전이나 CPU 사용량 등을 확인할 수 있는 속성 과 메서드를 제공

=>process.nextTick(콜백 함수): 다른 콜백 함수보다 우선해서 처리
Promise.resolve().then() 으로 작성 가능

=>process.exit(코드): 노드 프로세스 종료
서버에서는 사용하지 않는 것이 일반적이며 일반 애플리케이션을 만들었을 때 사용
코드는 운영체제에게 알려주는 종료 이유

8.노드에서 이벤트 처리
1)이벤트 연결
객체.addEventListener("이벤트 이름", 함수);
객체.on("이벤트 이름", 함수);

객체.once("이벤트 이름", 함수); //이벤트가 처음 발생할 때 만 함수를 수행하고 다음부터는 함수를 수행하지 않음

2)이벤트 삭제
객체.removeEventListener("이벤트 이름", 함수); //함수만 제거
객체.removeAllEventListener("이벤트 이름"); //모든 함수가 제거

3)이벤트 강제 발생
객체.emit("이벤트 이름");

4)이벤트에 10개 이상이 함수를 연결하고자 하는 경우
=>기본적으로 에러인데 객체.setMaxListeners(개수)를 호출하면 개수만큼 연결이 가능

9.예외처리
=>예외가 발생하게 되면 프로그램이 중단됩니다. 서버는 아주 위험한 예외가 아니라면 프로그램이 중단되면 안됩니다.
서버 프로그래밍에서는 대다수의 코드를 예외 처리 구문 안에 삽입을 해서 예외가 발생하면 예외를 기록하고 계속 작업을 수행하도록 해야 합니다.

try{
	예외 발생 가능성이 있는 코드
}catch(예외 객체){
	예외가 발생했을 때 수행할 내용
}finally{
	예외 발생 여부에 상관없이 수행할 동작
}
catch 와 finally 중 하나는 생략 가능합니다.
학습을 할 때는 catch 블럭에서 예외를 확인하는 코드를 작성하지만 실무에서는 예외를 기록하고 알림을 줍니다.

1)예외 처리의 목적
=>예외가 발생하더라도 계속 동작하기 위해서
=>예외를 로깅하기 위해서

2)예외 객체의 멤버
=>name: 예외 이름
=>message: 예외에 대한 설명

3)강제로 예외 발생
throw new Error("예외 메시지");

4)노드에서 예외가 발생해도 예외처리를 하지 않아도 되는 경우
=>콜백 함수의 매개변수가 예외 객체 인 경우는 예외 처리를 하지 않아도 됩니다.
이미 예외처리 구문으로 감싸져 있고 예외 객체를 넘겨주므로 예외 객체의 존재여부를 가지고 예외 발생 여부를 판단해서 작업만 작성해주면 됩니다.

10.자주 발생하는 에러
=>터미널에서 명령어를 입력했을 때 command not found 에러: 명령어를 잘못입력했거나 명령어가 없거나 명령어가 있는 곳을 path 라는 환경 변수에 설정을 하지 않은 경우

=>코드를 작성한 후 실행을 할 때 모듈이름 is not defined: 모듈을 가져오지 않았거나 모듈 이름을 잘못 기재한 경우

=>실행을 하다가 EADDRINUSE: 이미 포트를 사용 중인 경우, 포트를 사용 중인 프로세스를 종료하고 수행

=>프로세스 종료
Windows: taskkill /pid 프로세스아이디 /f
그 이외: kill -9 프로세스아이디

=>포트를 사용중인 프로세스 찾기
Windows: netstat -ano | findstr 포트번호
그 이외: lsof -l tcp:포트번호 
