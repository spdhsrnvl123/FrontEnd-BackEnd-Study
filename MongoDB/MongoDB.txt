**Mongo DB
1.Mongo DB
=>도큐먼트 지향 No SQL
=>JSON 형식의 BSON 이라는 데이터 구조를 사용
=>샤딩(데이터를 나누어서 저장하는 기술) 과 복제를 지원

2.설치 및 접속
1)Server 설치
=>windows: mongodb 사이트에서 다운로드 받아서 설치 - https://www.mongodb.com/try/download/community
=>mac(운영체제 업데이트를 한 경우에는 x-code-select --install 명령을 수행한 후 아래 명령 실행)
	brew tap mongodb/brew
	brew install mongodb-community
=>Linux는 종류 별로 다름: https://docs.mongodb.com/manual/administration/install-on-linux/

=>docker
이미지 다운로드: docker pull mongo
컨테이너 생성 및 실행: docker run --name 컨테이너이름 -d -p 27017:27017 mongo

2)Server 실행 - 포트 설정을 하지 않으면 27017 번 포트를 사용
=>Windows 
service 에 등록된 경우에는 service 에서 실행 과 중지 할 수 있음

cmd 창에서 mongod --dbpath 데이터저장경로 명령으로 실행 가능 - mongod 명령은 mongo db 설치 경로에 존재

명령어가 없다고 하면 mongodb 설치 경로의 bin 이라는 디렉토리로 프롬프트를 이동



=>Mac
 	brew services start mongodb-community
	brew services stop mongodb-community

3)외부 접속 허용
=>mongod.conf 파일이나 mongod.cfg 파일을 수정
Windows: Mongo DB 설치 경로의 bin 디렉토리에 파일이 존재
Mac: /usr/local/var/log/mongodb/mongo.log

=>bindIp 부분을 0.0.0.0 으로 설정하면 모든 곳에서 접속이 가능
# 으로 시작하면 주석이 됩니다.

=>윈도우즈는 설정 파일을 변경하고 서버를 실행할 때 mongod --dbpath 데이터저장경로 --bind_ip 0.0.0.0 으로 서버를 실행해야 합니다.

4)접속 프로그램
=>compass: windows에서는 mongodb 를 설치할 때 같이 설치
Mac에서는 https://www.mongodb.com/try/download/compass 

3.Mongo DB 구성 요소
database > collection > document

=>관계형 데이터베이스(RDBMS) 와 의 비교
Database - Database
Table(Relation) - Collection
Row(Record, Tuple) - Document
Column(Attribute) - Field
Index - Index
Join - Embedding & Linking
조회의 결과가 관계형 데이터베이스는 Row 의 집합인데 Mongo DB는 cursor

3.Mongo DB CRUD
=>JSON 형식
객체: {"속성 이름" : 값, "속성 이름" : 값...}
배열: [데이터, 데이터, ...]

값에 문자열, 숫자, boolean, 날짜, null 이 올 수 있고 다른 객체나 배열이 올 수 있습니다.
데이터 도 모든 종류의 값이 모두 올 수 있습니다.

1)데이터베이스 작업
=>Mongo DB에서 가장 큰 저장소의 개념
=>확인: show dbs
=>생성은 create로 할 수 있지만 use 데이터베이스이름 을 사용하면 가능
데이터베이스를 생성하더라도 데이터가 없으면 show dbs 에서 출력되지 않습니다.

=>데이터 삽입 을 한 후 show dbs 를 수행
db.mycollection.insertOne({name:"adam"});

2)collection
=>데이터의 집합
=>관계형 데이터베이스의 테이블 과 유사하지만 모든 종류의 데이터를 저장할 수 있다는 측면에서 보면 테이블 과는 다름
그렇지만 실제로는 대부분 동일한 모양의 데이터만 저장합니다.

=>collection 을 생성
db.createCollection("이름")

컬렉션을 만들지 않고 처음 사용하면 자동 생성

=>현재 존재하는 컬렉션을 확인
show collections

=>컬렉션 제거
db.컬렉션이름.drop()

=>컬렉션 이름 변경
db.컬렉션이름.renameCollection(변경할이름)

=>Capped Collection
크기를 제한해서 생성할 수 있는 컬렉션으로 크기보다 많은 양의 데이터를 저장하고자 하면 오래된 데이터가 삭제되면서 저장이 됩니다.

db.createCollection(컬렉션이름,{capped:true, size:크기})

크기 단위는 byte

용량 제한이 없으므로 0번 데이터부터 모두 존재
> db.createCollection("noCapCollection")
> for(i=0; i<1000; i++){db.noCapCollection.insertOne({x:i})}
> db.noCapCollection.find()

용량 제한을 설정했으므로 오래된 데이터는 삭제
>db.createCollection("cappedCollection", {capped:true, size:1000})
>for(i=0; i<1000; i++){db.cappedCollection.insertOne({x:i})}
>db.cappedCollection.find()

3)Document 생성 - 데이터 삽입
=>데이터는 객체 형태로 삽입을 해야 합니다.
=>_id 라는 속성을 설정하지 않으면 Mongo DB가 ObjectId 타입으로 _id 값을 생성해서 삽입합니다.
이 값이 Primary Key 이면서 Index
=>삽입을 할 때는 insert, insertOne, insertMany, save 함수를 이용하는 것이 가능
insert는 현재 버전에서는 deprecated
insertOne 은 하나의 데이터를 대입하지만 insertMany는 배열의 형태로 대입하면 됩니다.

=>insert를 이용한 삽입
> db.users.insert({name:"adam", age:25, gender:"man"})

> db.users.find()

> db.inventory.insert({
	item:"ABC1",
	details:{
		model:"123",
		manufacture:"xyz"
	},
	stock:[{size:"s", qty:25},{size:"m", qty:20}],
	category:"clothing"
})

> db.inventory.find()

관계형 데이터베이스는 테이블의 컬럼 안에 하나의 값만 입력할 수 있습니다.
다른 테이블의 데이터나 배열을 대입할 수 없습니다.
이런 이유로 여러 개의 테이블을 만들어야 하고 여러 정보를 가져오기 위해서는 join을 수행해야 합니다.

root 가 배열인 경우 데이터를 분할해서 삽입

> db.users.insert([{name:"matt"}, {name:"lara"}])

> db.users.find()

=>데이터를 삽입할 때 두번째 매개변수로 ordered 옵션에 true를 설정하면 single thread 형태로 데이터를 삽입하고 false를 설정하면 멀티 스레드 형태로 삽입합니다.
스레드는 다른 스레드에 영향을 주지 않습니다.
ordered 가 true 이면 중간에 삽입 실패를 하면 다음 작업을 수행하지 않지만 ordered를 false로 설정하면 중간에 작업이 실패하더라도 나머지 작업을 수행합니다.

#sample 컬렉션에 name 속성의 값은 중복되지 않도록 인덱스를 생성
> db.sample.createIndex({name:1}, {unique:true})

> db.sample.insert({name:"adam"})

#3개의 데이터를 삽입하는데 두번째 데이터는 이미 존재하는 아담을 삽입 - 싱글 스레드
> db.sample.insert([{name:"karina"}, {name:"adam"}, {name:"minji"}], {ordered:true});

#adam에서 에러가 발생해서 minji는 삽입이 안됨
>db.sample.find()

#sample을 삭제
> db.sample.drop();

#sample 컬렉션에 name 속성의 값은 중복되지 않도록 인덱스를 생성
> db.sample.createIndex({name:1}, {unique:true})

> db.sample.insert({name:"adam"})

#3개의 데이터를 삽입하는데 두번째 데이터는 이미 존재하는 아담을 삽입 - 멀티 스레드
> db.sample.insert([{name:"karina"}, {name:"adam"}, {name:"minji"}], {ordered:false});

#adam에서 에러가 발생했지만 다른 작업은 별도의 스레드로 수행되므로 minji는 삽입이 됨
>db.sample.find()

=>insertOne 은 하나의 데이터를 삽입할 때 사용하고 insertMany는 여러 개의 데이터를 삽입할 때 사용하는 함수

=>ObjectId: MongoDB의 자료형으로 12byte 로 구성
컬렉션에 기본키를 생성하기 위해서 제공되는 자료형
삽입할 때 _id 라는 컬럼에 자동으로 대입됩니다.
직접 설정하는 것도 가능한데 이 경우에는 new ObjectId() 로 인스턴스를 생성해서 대입하면 됩니다.

4)조회
=>db.컬렉션이름.find(<query>, <projection>)
selection: select 구문에서 where 절에 해당하는 것으로 조건을 가지고 테이블을 수평 분할하기 위한 연산
projection: select 구문에서 select 절에 해당하는 것으로 컬럼 이름을 가지고 테이블을 수직 분할하기 위한 연산

=>컬렉션의 전체 데이터 조회
db.컬렉션이름.find()

#users 컬렉션의 모든 데이터 조회
> db.users.find()

=>조건을 이용한 조회
db.컬렉션이름.find({조건})

#users 컬렉션의 name 이 adam 인 데이터 조회
> db.users.find({name:"adam"})

#하나의 객체에 여러 속성의 값을 나열하면 and
#containerBox 컬렉션에서 category는 animal 이고 name 은 bear 인 데이터 조회
> db.containerBox.find({category:'animal', name:'bear'})

=>컬럼 추출
db.컬렉션이름.find({}, {속성이름:true 또는 false, ...})
true를 설정하면 출력되고 false 이면 출력되지 않음

=>비교 연산자
$eq: =
$ne: !=
$gt: >
$gte: >=
$lt: <
$lte: <=
$in: in
$nin: not in

HTML 에서는 부등호가 태그를 열고 닫는 기호입니다.
> db.users.find({name:{$eq:"adam"}})
> db.users.find({score:{$ge:90}})
> db.users.find({name:{$in:["adam", "matt"]}})

조회를 할 때 문자열 자리에 정규 표현식을 사용하는 것이 가능
#b로 시작하는
> db.users.find({name:{$in:[/^b/]}})

=>논리 연산자
$not
$or
$and
$nor
not을 제외하고는 조건을 배열의 형태로 설정

#inventory 에서 qty 가 100보다 크거나 qty 가 10보다 작은 데이터 조회
db.inventory.find({$or:[{qty:{$gt:100}}, {qty:{$lt:10}}]})

=>문자열 검색 - 값에 정규식 사용 가능
#샘플 데이터 삽입
> db.users.insert({name:'paulo'})
> db.users.insert({name:'patric'})
> db.users.insert({name:'pedro'})

#a가 포함된 데이터 조회
> db.users.find({name:/a/})

#pa로 시작하는 데이터 조회
> db.users.find({name:/^pa/})

#ro로 끝나는 데이터 조회
> db.users.find({name:/ro$/})

=>데이터 개수 제한은 limit 함수
#users 테이블에서 데이터 2개만 조회
>db.users.find().limit(2)

#1개만 조회시에는 findOne 함수를 이용해도 됨

=>건너뛰기는 skip 함수

=>데이터 정렬은 sort 함수
sort({속성이름: 1이나 -1,...})
1은 오름차순이고 -1은 내림차순

속성 이름 대신에 natural을 이용하면 삽입한 순서대로 조회가 가능합니다.

=>Cursor
find 함수의 결과로 리턴되는 자료형으로 도큐먼트를 순서대로 접근할 수 있도록 해주는 포인터
프로그래밍 언어의 Enumeration(Enumerator) 나 Iterator 와 유사한 개념
커서에는 hasNext() 함수 와 next() 가 존재하는데 다음 데이터의 존재 여부를 리턴하고 뒤의 함수는 다음 데이터를 리턴합니다.

5)수정
=>함수
update
updateOne
updateMany
replaceOne

=>형식
update({조건}, {수정할 형식})
수정할 형식은 {$set:{속성이름:수정할 데이터,....}}

>db.users.update({name:"adam"}, {$set:{score:100}})

6)데이터 삭제
=>remove, deleteOne, deleteMany
>db.users.deleteOne({name:"adam"})

7)트랜잭션 처리
=>Mongo DB는 느슨한 트랜잭션을 지원
=>트랜잭션 처리가 중요한 업무에서는 Mongo DB를 잘 사용하지 않음

트랜잭션 시작
session = db.getMongo().startSession()
session.startTransaction();

작업 수행
session.commitTransaction() 이나 session.abortTransaction() 을 호출


4.Node + MongoDB
=>Mongo DB 연결
드라이버 패키지: mongodb

연결 코드
let MongoClient = require('mongodb').MongoClient
MongoClient.connect('mongodb://아이디:비밀번호@ip:포트번호', (err, database) => {
	if(err){
		//에러가 발생했을 때 처리
	}else{
		//정상적으로 처리되었을 때 처리
		let db = database.db('데이터베이스이름');
		db를 가지고 작업을 수행
	}
});

1)샘플 데이터를 입력
use node

db.item.insert({'itemid':1, 'itemname':'레몬', 'price':500, 'description':'비타민 C가 풍부한 쓴 귤', 'pictureurl':'lemon.jpg'})

db.item.insert({'itemid':2, 'itemname':'오렌지', 'price':1500, 'description':'비타민 C가 풍부한 당귤', 'pictureurl':'orange.jpg'})

db.item.insert({'itemid':3, 'itemname':'키위', 'price':2000, 'description':'비타민 C가풍부한 다래', 'pictureurl':'kiwi.jpg'})

db.item.insert({'itemid':4, 'itemname':'포도', 'price':1000, 'description':'항산화 성분과 당분이 높고 무기물이 많은 과일', 'pictureurl':'grape.jpg'})

db.item.insert({'itemid':5, 'itemname':'딸기', 'price':2000, 'description':'수분 함량이 높은 과일', 'pictureurl':'strawberry.jpg'})

db.item.insert({'itemid':6, 'itemname':'무화과', 'price':300, 'description':'칼슘, 섬유질 및 항산화 물질을 많이 함유한 식물', 'pictureurl':'fig.jpg'})

>db.item.find()  명령으로 확인

2)node 프로젝트 생성
=>entry point 는 App.js

=>필요한 패키지 설치
express, morgan, multer, mongodb, ejs
개발 모드(--save-dev 옵션을 추가해서 설치)로 nodemon

=>필요한 디렉토리 생성 - img 와 views 디렉토리 생성

=>package.json 파일의 속성 수정
"scripts": {
    "start":"nodemon app",
    "test": "echo \"Error: no test specified\" && exit 1"
  },

3)App.js 파일에 기본 설정 코드를 추가하고 실행
const express = require('express');
const morgan = require('morgan');
const path = require('path');
const multer = require('multer');
const fs = require('fs')

//express web application server 를 9000번 포트로 생성
const app = express();
app.set('port', process.env.PORT || 9000);

//로그를 화면에 출력
app.use(morgan('dev'));

//form 이 아닌 형태의 POST 방식의 파라미터를 읽기 위한 설정
let bodyParser = require('body-parser')
app.use( bodyParser.json() );       // to support JSON-encoded bodies
app.use(bodyParser.urlencoded({     // to support URL-encoded bodies
	extended: true
})); 


//파일 다운로드를 구현하기 위한 모듈
let util = require('util')
let mime = require('mime')

//파일 업로드를 위한 디렉토리를 없으면 생성
try {
	fs.readdirSync('img');
} catch (error) {
	console.error('img 폴더가 없어 img 폴더를 생성합니다.');
	fs.mkdirSync('img');
}

//파일 업로드 설정
const upload = multer({
	storage: multer.diskStorage({
		destination(req, file, done) {
            //업로드할 디렉토리 설정
			done(null, 'img/');
		},
		filename(req, file, done) {
            //업로드 될 때의 파일 이름 설정
			const ext = path.extname(file.originalname);
			done(null, path.basename(file.originalname, ext) + Date.now() + ext);
		},
	}),
	limits: { fileSize: 10 * 1024 * 1024 },
});

//템플릿 엔진(서버의 데이터를 html에 출력하기 위한 모듈) 설정
app.set('view engine', 'html');
app.engine('html', require('ejs').renderFile);

//Mongo DB 사용을 위한 모듈 가져오기
let MongoClient = require('mongodb').MongoClient;
//접속할 데이터베이스 URL 설정
let databaseUrl = 'mongodb://localhost:27017/';

//에러 처리를 위한 부분
app.use((err, req, res, next) => {
    console.error(err);
    res.status(500).send(message);
});

//서버 구동
app.listen(app.get('port'), () => {
    console.log(app.get('port'), '번 포트에서 대기 중');
})

4)App.js 파일에 컬렉션의 모든 데이터 가져오기 구현
//node 데이터베이스의 item 컬렉션에 존재하는 모든 데이터를 리턴
app.get('/item/all', (req, res)=>{
    //데이터베이스 연결
    MongoClient.connect(databaseUrl, {useNewUrlParser:true},
        (error, database) => {
            if(error){
                console.log(error);
                res.json({"result":false, "message":"이유"});
            }else{
                //데이터베이스 가져오기
                let db = database.db('node');
                //item 컬렉션의 모든 데이터 가져오기
                db.collection('item').find().sort({itemid:-1})
                    .toArray((error, items) => {
                      if(error){
                        console.log(error);
                        res.json({"result":false, "message":"이유"});
                      }else{
                        res.json({"result":true, "list":items,
                            "count":items.length});
                      } 
                });
                
            }
    });
})

5)App.js 파일에 페이지 단위로 가져오기 구현
//node 데이터베이스의 item 컬렉션의 데이터를 페이지 단위로 가져오기

//데이터베이스에서 페이지 단위로 데이터를 가져올 때는
//건너뛸 개수 와 가져올 데이터 개수가 필요

//클라이언트에서 넘겨주는 데이터: 페이지 번호 와 데이터 개수
app.get('/item/paging', (req, res)=>{
    //클라이언트의 데이터 받아오기
    let pageno = req.query.pageno; //페이지 번호
    let count = req.query.count; //한 번에 가져올 데이터 개수
    console.log("에러1");
    //건너뛸 개수 계산
    if(pageno == undefined){
        pageno = 1;
    }
    if(count == undefined){
        count = 2;
    }
    console.log("에러2");
    //웹에서 클라이언트가 전송하는 데이터는 기본적으로
    //무조건 문자열입니다.
    //계산을 할 때는 숫자로 변형을 해서 계산을 해야 합니다.
    let start = (parseInt(pageno) - 1) * parseInt(count);

    //데이터베이스 연결
    MongoClient.connect(databaseUrl, {useNewUrlParser:true},
        (error, database) => {
            if(error){
                console.log(error);
                res.json({"result":false, "message":"이유"});
            }else{
                //데이터베이스 가져오기
                let db = database.db('node');
                //item 컬렉션의 모든 데이터 가져오기
                db.collection('item').find().sort({itemid:-1})
                .skip(start).limit(parseInt(count))
                    .toArray((error, items) => {
                      if(error){
                        console.log(error);
                        res.json({"result":false, "message":"이유"});
                      }else{
                        res.json({"result":true, "list":items,
                            "count":items.length});
                      } 
                });
                
            }
    });
})
=>확인
localhost:9000/item/paging -> 파라미터 없이 확인
localhost:9000/item/paging?pageno=2&count=2 -> 파라미터를 주고 확인

6)데이터 상세보기를 App.js에 구현
//상세보기
//기본키 하나의 데이터를 필요로 하는 경우가 많고
//결과는 하나의 데이터를 리턴하는 경우가 많고
//그 이외에 주위의 3 - 10 여 개의 같이 리턴하는 경우도 많음
app.get('/item/:itemid', (req, res) => {
    //클라이언트의 데이터 받아오기
    //url에 포함된 데이터 받기
    let itemid = req.params.itemid;

    //데이터베이스 연결
    MongoClient.connect(databaseUrl, { useNewUrlParser: true },
        (error, database) => {
            if (error) {
                console.log(error);
                res.json({ "result": false, "message": "이유" });
            } else {
                //데이터베이스 가져오기
                let db = database.db('node');
                //item 컬렉션의 모든 데이터 가져오기
                db.collection('item')
                    .findOne({ "itemid": Number(itemid) }, (error, item) => {
                        if (error) {
                            console.log(error);
                            res.json({ "result": false, "message": "이유" });
                        } else {
                            res.json({ "result": true, "item": item })
                        }
                    });
            }
        });
})

=>확인: http://localhost:9000/item/3

7)데이터 삽입을 App.js에 구현
//데이터 삽입 구현
//itemname, description, price, pictureurl(파일) 받기
app.post('/item', upload.single('pictureurl'), (req, res) => {
    //파라미터 읽어오기
    const itemname = req.body.itemname;
    const description = req.body.description;
    const price = req.body.price;
    let pictureurl;
    //업로드한 파일이 있으면 파일의 이름을 설정하고
    //없으면 디폴트 값 설정
    if(req.file){
        pictureurl = req.file.filename;
    }else{
        pictureurl = 'default.jpg';
    }

    MongoClient.connect(databaseUrl, {useNewUrlParser:true},
        (error, database) => {
            if(error){
                console.log(error);
                res.json({"result":false});
            }else{
                let db = database.db('node');
                //가장 큰 itemid를 찾아오기
                db.collection("item").find({},
                    {projection:{_id:0, itemid:1}})
                    .sort({itemid:-1}).limit(1)
                    .toArray((error, result) => {
                        let itemid = 1;
                        if(result[0] != null){
                            itemid = result[0].itemid + 1;
                        }
                        db.collection('item').insertOne({
                            "itemid":itemid,
                            "itemname":itemname,
                            "descritpion":description,
                            "price":price,
                            "pictureurl":pictureurl
                        }, (error, result) => {
                            if(error){res.json({"result":false})}
                            else{res.json({"result":true})}
                        })
                })
            }
    })
});

=>확인 - 화면을 만들고 테스트 할 수 있고 Postman 과 같은 프로그램을 이용

8)수정
.update({속성이름:값}, {$set:{속성이름:수정할 값,...}}, (error, result)=> { })
.update({"itemid":아이디값}, {$set:{"itemname":itemname,...}}, (error, result)=> { })

9)삭제
.deleteOne({속성이름:값}, (error, result)=> { })
=>주의할 점은 Mongo DB는 숫자 와 문자열을 명확하게 구분


5.Node + MongoDB + mongoose(Node 의 ODM)







	