2.Built In(내장) 함수
=>JavaScript에서 제공하는 함수로 실제로는 window 객체의 메서드인데 window 객체를 이용해서 내부 요소를 호출할 때는 window.을 생략할 수 있어서 전역 함수처럼 사용합니다.

1)alert
=>메시지를 대화상자에 출력할 때 사용하는 함수
alert(메시지) 형태로 사용하는데 return 되는 데이터가 없음

2)confirm
=>메시지를 대화상자에 출력하고 버튼을 2개 제공하는데 확인 버튼을 누르면 true 가 리턴되고 취소 버튼을 누르면 false 가 리턴됨

3)prompt
=>한 줄의 문자열을 입력받을 수 있는 대화상자로 prompt(메시지, 기본값) 으로 호출하고 확인 과 취소 버튼이 만들어지는데 확인을 누르면 입력한 문자열이 리턴되고 취소를 누르면 null 이 리턴됩니다.

4)eval
=>문자열을 대입하면 이에 해당하는 DOM 객체를 찾아서 리턴해주는 함수
=>예전에는 사용을 했는데 최근에는 document.getElementById를 권장하기 때문에 거의 사용되지 않음

5)인코딩 및 디코딩 관련 함수
=>Encoding: 데이터를 컴퓨터에 저장하는 형태로 만드는 것
JavaScript에서 서버에게 데이터를 전송할 때 get 방식을 사용하는 경우 query string(parameter)은 반드시 encoding을 해서 전송해야 합니다.
query string에 한글이 포함되어 있는데 인코딩하지 않고 전송하면 글자가 깨짐

escape(문자열): 일부 특수문자(@, *, -, _, +, ., /)를 제외한 모든 문자를 인코딩
encodeURI(문자열): 인터넷 주소에 사용되는 문자를 제외한 모든 문자를 인코딩 - 주로 사용
encodeURIComponent(문자열): 알파벳 과 숫자를 제외한 모든 문자를 인코딩

=>Decoding: 컴퓨터에 저장된 데이터를 출력하기 위한 형태로 만드는 것
unescape
decodeURI
decodeURIComponent

6)isNaN
=>NaN 여부를 판단하는 함수

7)isFinite
=>유한수 인지 판단하는 함수

8)parseInt 와 parseFloat
=>문자열을 정수 나 실수로 변경해주는 함수
=>숫자를 문자열로 변환은 new String(숫자 데이터) 을 이용하라고 하는데 숫자+"" 로 도 가능

**JavaScript 의 OOP(Object Oriented Programming - 객체 지향 프로그래밍)
=>ES5 까지는 클래스의 개념이 없어서 OOP 의 개념이 아님 - 객체 기반 언어
ECMA 2015에서 클래스의 개념이 도입됨

1.객체 지향 의 3대 특징
1)Encapsulation(캡슐화)
=>불필요한 부분을 숨기고 하나로 만드는 것
=>클래스를 만드는 것 과 인스턴스 만드는 것 그리고 접근 지정자를 학습

2)Inheritance(상속)
=>하위 클래스가 상위 클래스의 모든 것을 물려받는 것

3)Polymorphsim(다형성)
=>동일한 메시지에 대하여 다르게 반응하는 성질
=>동일한 코드가 호출하는 객체에 따라 다른 메서드를 호출하는 성질
=>상속 과 오버라이딩(가끔은 오버라이딩이 아니라 구현)으로 구현됨

2.객체(Object)
=>데이터를 저장할 수 있는 속성(variable - property) 과 기능을 수행하는 메서드(function - method)를 모아놓은 것
=>종류
사용자 정의 객체 : 개발자가 필요에 의해서 생성

내장 객체 : JavaScript에서 제공하는 객체 - API(Application Programming Interface) 나 SDK(Software Developement Kit) 라고도 함

3rd Party 객체 : 다른 개발자나 회사가 제공(Library, Framework : Solution)

3.사용자 정의 객체
1)생성
=>var(let 이나 const) 이름 = {"속성이름": 데이터, "메서드이름": 메서드 코드...}
=>var(let 이나 const) 이름 = new 생성자(매개변수 나열)

2)내부 요소 호출(.을 이용합니다.)
이름.속성이름

이름.메서드이름(매개변수)

=>. 대신에 [속성이름] 으로 속성 호출이 가능한데 이 때는 문자열 형태(작은 따옴표 나 큰 따옴표로 감싸야 함)로 입력해야 합니다.

var obj = {"name":"adam"};
obj.name
obj["name"]

=>내부 속성은 중복해서 만들어지지 않기 때문에 동일한 이름에 2번 삽입하면 이전 내용이 없어지고 새로운 내용으로 변경됩니다.

3)for in
for(임시변수 in 객체){수행할 내용}
=>객체의 모든 속성의 이름을 임시변수에 문자열 형태로 대입하고 { } 안의 내용을 반복 수행

4)속성이름 in 객체
=>속성이 객체 존재하는지 여부를 판단해서 Boolean 으로 리턴

5)with 블럭
with(객체이름){
//이 안에서는 객체 이름을 생략해도 됨
}

6)속성 추가 및 수정
객체이름.속성이름 = 데이터 또는 함수;
=>존재하는 속성이면 수정이고 존재하지 않는 속성이면 추가

7)속성 삭제
delete(객체이름.속성이름)

8)this
=>객체 안에 존재하는 메서드에 존재하는 숨겨진 매개변수
=>객체 안에 만들어진 메서드에서는 this 라는 변수를 사용할 수 있는데 이 this는 객체를 참조합니다.
=>객체 안에 만들어진 메서드에서 객체의 속성을 이용할 때는 this.속성이름의 형태로 사용해야 합니다.
this를 붙이지 않으면 메서드 안에서 이름을 찾게 됩니다.
=>화살표 함수에서는 this를 사용할 수 없습니다.














